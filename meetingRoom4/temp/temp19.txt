userRouter.jsconst express = require("express");
const router = express.Router();
const { userController } = require("../controllers/userController");
const { verifyAndAttachUser } = require("../middlewares/auth/auth"); // Import auth

const {
	registerValidator,
	loginValidator,
} = require("../validators/userValidator");

// Route for user registration
router.post("/register", registerValidator, userController.register);

// Route for user login
router.post("/login", loginValidator, userController.login);

// Route to get all users
router.get("/users", userController.getAllUsers);

// Route to get a user by ID
router.get("/search/userID/:userID", userController.getUserByID);

// Route to get a user by name
router.get("/search/userName/:username", userController.getUserByName);

// Route to delete a user by ID (requires authentication)
router.delete(
	"/delete/userID/:userID",
	verifyAndAttachUser,
	userController.deleteUserByID
);

// Route to delete a user by username (requires authentication)
router.delete(
	"/delete/userName/:username",
	verifyAndAttachUser,
	userController.deleteUserByName
);

module.exports = router;


roomRouter.js:
// roomRouter.js

const express = require("express");
const router = express.Router();
const { roomController } = require("../controllers/roomController");
const { auth } = require("../middlewares/auth/auth"); // Import the auth
const { createRoomValidator } = require("../validators/roomValidator");

// Apply auth to routes that require authentication
router.post("/create", auth, createRoomValidator, roomController.createRoom); // Route to create a room
router.get("/rooms", auth, roomController.getAllRooms); // Route to get all rooms
router.get("/search/roomID/:roomID", auth, roomController.getRoomByID); // Route to get a room by ID
router.get("/search/roomName/:roomName", auth, roomController.getRoomByName); // Route to get a room by name
router.delete("/delete/roomID/:roomID", auth, roomController.deleteRoomByID); // Route to delete a room by ID
router.delete(
	"/delete/roomName/:roomName",
	auth,
	roomController.deleteRoomByName
); // Route to delete a room by name

module.exports = router;


meetingRouter.js:
const express = require("express");
const router = express.Router();
const { meetingController } = require("../controllers/meetingController");
const { auth } = require("../middlewares/auth"); // Import the auth
const { createMeetingValidator } = require("../validators/meetingValidator");

// Apply auth to routes that require authentication
router.post(
	"/create",
	auth,
	createMeetingValidator,
	meetingController.createMeeting
); // Route to create a new meeting
router.get("/meetings", auth, meetingController.getAllMeetings); // Route to get all meetings
router.get(
	"/search/between/:queryDateStart/:queryDateEnd/:roomID",
	auth,
	meetingController.getAllMeetingsBetween
); // Route to get all meetings between two dates
router.get(
	"/search/:roomID/:meetingDate",
	auth,
	meetingController.getMeetingsByRoomDate
); // Route to get meetings by room ID
router.delete(
	"/delete/meetingID/:meetingID",
	auth,
	meetingController.deleteMeetingByID
); // Route to delete a meeting by ID
router.delete(
	"/delete/byInfo/:roomID/:meetingDate/:meetingStart",
	auth,
	meetingController.deleteMeetingByInfo
); // Route to delete a meeting by info

module.exports = router;

// DELETE Meeting by ID Example Cycle:
// - Client sends a DELETE request to the server with the meeting ID included in the URL parameter.
// - Express routes the request to the appropriate route handler in meetingRouter.js.
// - The request passes through the auth, which verifies the access token stored in the client's cookies.
// - If the access token is valid, the middleware attaches the decoded user information to the request object.
// - The route handler executes the deleteMeetingByID controller function, which attempts to delete the meeting from the database.
// - The controller interacts with the database to perform the deletion operation.
// - Depending on the outcome, the server sends an appropriate HTTP response back to the client.
// - The client receives the response and updates its interface accordingly.


authRouter.js:
const express = require("express");
const jwt = require("jsonwebtoken");
const { verifyAndAttachUser } = require("../middlewares/auth");
const router = express.Router();

// Middleware to parse cookies
router.use(cookieParser());

// Route to decode the token cookie
router.get("/decodeToken", verifyAndAttachUser, (req, res) => {
	const decoded = req.user;
	res.json({ decoded });
});

module.exports = router;


userController.js:
// userController.js

const { User, connect } = require("../configs/dbConfig"); // importing relevant model (with sequelize) from dbconfig
const { auth, tokens, cookies } = require("../middlewares/auth/auth"); // Import the auth object from auth.js

exports.userController = {
	// Controller function to register a new user
	async register(req, res) {
		await connect();
		try {
			const { username, password, permission, department } = req.body;

			// Check if a user with the same username already exists
			const existingUser = await User.findOne({
				where: { username },
			});
			if (existingUser) {
				return res.status(400).json({ message: "Username is already taken" });
			}

			// Hash the password
			const hashedPassword = await auth.hashPassword(password);

			// Create a new user in the database
			const newUser = await User.create({
				username,
				password: hashedPassword,
				permission,
				department,
			});

			res.status(201).json(newUser);
		} catch (error) {
			console.error("Error registering user:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	async login(req, res) {
		await connect();
		try {
			const { username, password } = req.body;

			// Find the user in the database
			const user = await User.findOne({
				where: { username },
			});

			if (!user) {
				return res
					.status(401)
					.json({ message: "Invalid username or password" });
			}

			// Check password
			const passwordMatch = await auth.checkPassword(password, user.password);
			if (!passwordMatch) {
				return res
					.status(401)
					.json({ message: "Invalid username or password" });
			}

			// Generate JWT token
			const token = tokens.generateAccessToken(user, res);
			res.json({ token });
		} catch (error) {
			console.error("Error logging in user:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	// Function to get all users
	async getAllUsers(req, res) {
		await connect();
		try {
			// Retrieve all rooms from the database
			const users = await User.findAll();
			res.json(users);
		} catch (error) {
			console.error("Error retrieving users:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	// Controller function to get a room by ID
	async getUserByID(req, res) {
		await connect();
		try {
			const { userID } = req.params;
			const user = await User.findByPk(userID);
			if (!user) {
				return res.status(404).json({ message: "User not found" });
			}
			res.json(user);
		} catch (error) {
			console.error("Error retrieving user:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	// Controller function to get a user by name
	async getUserByName(req, res) {
		await connect();
		try {
			const { username } = req.params;
			const user = await User.findOne({ where: { username } });
			if (!user) {
				return res.status(404).json({ message: "User not found" });
			}
			res.json(user);
		} catch (error) {
			console.error("Error retrieving user:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	// Controller function to delete a user by ID
	async deleteUserByID(req, res) {
		await connect();
		try {
			const { userID } = req.params;

			// Find the user by ID
			const user = await User.findByPk(userID);
			if (!user) {
				return res.status(404).json({ message: "User not found" });
			}

			// Delete the user
			await user.destroy();

			res.json({ message: "User deleted successfully" });
		} catch (error) {
			console.error("Error deleting user:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	// Controller function to delete a user by username
	async deleteUserByName(req, res) {
		await connect();
		try {
			const { username } = req.params;

			// Find the user by username
			const user = await User.findOne({ where: { username } });
			if (!user) {
				return res.status(404).json({ message: "User not found" });
			}

			// Delete the user
			await user.destroy();

			res.json({ message: "User deleted successfully" });
		} catch (error) {
			console.error("Error deleting user:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},
};


roomController.js:
const { Room, connect } = require("../configs/dbConfig"); // importing relevant model (with sequelize) from dbconfig

exports.roomController = {
	// Controller functions for room operations
	async createRoom(req, res) {
		await connect();
		try {
			// Extract room data from request body
			const { roomName, minPermission, department } = req.body;

			// Create a new room record in the database
			const newRoom = await Room.create({
				roomName,
				minPermission,
				department,
			});

			res.status(201).json(newRoom);
		} catch (error) {
			console.error("Error creating room:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	// Function to get all rooms
	async getAllRooms(req, res) {
		await connect();
		try {
			// Retrieve all rooms from the database
			const rooms = await Room.findAll();
			res.json(rooms);
		} catch (error) {
			console.error("Error retrieving rooms:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	// Controller function to get a room by ID
	async getRoomByID(req, res) {
		await connect();
		try {
			const { roomID } = req.params;
			const room = await Room.findByPk(roomID);
			if (!room) {
				return res.status(404).json({ message: "Room not found" });
			}
			res.json(room);
		} catch (error) {
			console.error("Error retrieving room:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	// Controller function to get a room by name
	async getRoomByName(req, res) {
		await connect();
		try {
			const { roomName } = req.params;
			const room = await Room.findOne({ where: { roomName } });
			if (!room) {
				return res.status(404).json({ message: "Room not found" });
			}
			res.json(room);
		} catch (error) {
			console.error("Error retrieving room:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	async deleteRoomByID(req, res) {
		await connect();
		try {
			// Extract room ID from request parameters
			const { roomID } = req.params;

			// Find the room by ID and delete it
			const deletedRoom = await Room.destroy({ where: { roomID: roomID } });

			if (!deletedRoom) {
				return res.status(404).json({ message: "Room not found" });
			}

			res.json({ message: "Room deleted successfully" });
		} catch (error) {
			console.error("Error deleting room:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	async deleteRoomByName(req, res) {
		await connect();
		try {
			// Extract room name from request parameters
			const { roomName } = req.params;

			// Find the room by name and delete it
			const deletedRoom = await Room.destroy({ where: { roomName } });

			if (!deletedRoom) {
				return res.status(404).json({ message: "Room not found" });
			}

			res.json({ message: "Room deleted successfully" });
		} catch (error) {
			console.error("Error deleting room:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},
};


meetingController.js:
// meetingController.js

const {
	Meeting,
	Room,
	User,
	connect,
	sequelize,
} = require("../configs/dbConfig");
const { Op } = require("sequelize");

exports.meetingController = {
	async createMeeting(req, res) {
		await connect();
		try {
			const { userID, roomID, meetingDate, meetingStart, meetingEnd } =
				req.body;

			// Check if the user has permission to create a meeting in the specified room

			const room = await Room.findByPk(roomID);
			const user = await User.findByPk(userID);

			if (!room || user.permission > room.minPermission) {
				return res.status(403).json({
					message: "Insufficient clearance to create a meeting in this room",
				});
			}

			// this is where you would try to get userID from the encrypted cookie and attempt to decrypt it to create a meeting
			// currently pass userID into it manually

			// Create the meeting
			const meeting = await Meeting.create({
				userID,
				roomID,
				meetingDate,
				meetingStart,
				meetingEnd,
			});

			res.status(201).json(meeting);
		} catch (error) {
			console.error("Error creating meeting:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	async getAllMeetings(req, res) {
		await connect();
		try {
			const meetings = await Meeting.findAll();
			res.json(meetings);
		} catch (error) {
			console.error("Error retrieving meetings:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	async getMeetingsByRoomDate(req, res) {
		await connect();
		try {
			const { roomID, meetingDate } = req.params;

			// Find the room by ID
			const room = await Room.findByPk(roomID);
			if (!room) {
				return res.status(404).json({ message: "Room not found" });
			}

			const meetings = await Meeting.findAll({
				where: { roomID, meetingDate },
			});
			res.json(meetings);
		} catch (error) {
			console.error("Error retrieving meetings:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	async getAllMeetingsBetween(req, res) {
		await connect();
		try {
			const { queryDateStart, queryDateEnd, roomID } = req.params;

			// Find all meetings between the specified dates
			const meetings = await Meeting.findAll({
				where: {
					meetingDate: {
						[Op.between]: [queryDateStart, queryDateEnd],
					},
					roomID: roomID,
				},
			});

			res.status(200).json(meetings);
		} catch (error) {
			console.error("Error retrieving meetings between dates:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	async deleteMeetingByID(req, res) {
		await connect();
		try {
			const { meetingID } = req.params;

			// Find the meeting by ID
			const meeting = await Meeting.findByPk(meetingID);
			if (!meeting) {
				return res.status(404).json({ message: "Meeting not found" });
			}

			// Check if the user has permission to delete the meeting (assuming permission checks)
			// Additional permission logic can be added here

			// Delete the meeting
			await meeting.destroy();

			res.json({ message: "Meeting deleted successfully" });
		} catch (error) {
			console.error("Error deleting meeting:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	async deleteMeetingByInfo(req, res) {
		await connect();
		try {
			const { roomID, meetingDate, meetingStart } = req.params;

			// Find the meeting by ID
			const meeting = await Meeting.findOne({
				where: { roomID, meetingDate, meetingStart },
			});
			if (!meeting) {
				return res.status(404).json({ message: "Meeting not found" });
			}

			// Check if the user has permission to delete the meeting (assuming permission checks)
			// Additional permission logic can be added here

			// Delete the meeting
			await meeting.destroy();

			res.json({ message: "Meeting deleted successfully" });
		} catch (error) {
			console.error("Error deleting meeting:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},
};


auth.js:
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const { serialize, parse } = require("cookie");
require("dotenv").config();

// Load environment variables
const JWT_SECRET = process.env.JWT_SECRET;
const REFRESH_TOKEN_SECRET = process.env.REFRESH_TOKEN_SECRET;

// Number of salt rounds for password hashing
const saltRounds = 10;

exports.auth = {
	// Functions related to authentication (password hashing and verification)
	async hashPassword(password) {
		return await bcrypt.hash(password, saltRounds);
	},

	async checkPassword(password, hashedPassword) {
		return await bcrypt.compare(password, hashedPassword);
	},
};

exports.tokens = {
	// Functions related to tokens
	async generateAccessToken(userID) {
		return jwt.sign({ userID }, JWT_SECRET, { expiresIn: "15m" });
	},

	async generateRefreshToken(userID) {
		return jwt.sign({ userID }, REFRESH_TOKEN_SECRET, { expiresIn: "1.5h" });
	},
};

exports.cookies = {
	// Functions related to cookies
	async parseCookies(cookieHeader) {
		return parse(cookieHeader);
	},

	async verifyAndAttachUser(req, res, next) {
		const cookieHeader = req.headers.cookie;
		if (!cookieHeader) {
			return res.status(401).json({ message: "No cookies sent" });
		}

		const cookies = parse(cookieHeader);
		const token = cookies.token;

		if (!token) {
			return res.status(401).json({ message: "Token not found in cookies" });
		}

		try {
			const decoded = jwt.verify(token, JWT_SECRET);
			req.user = decoded; // Attach the decoded token to the request object
			next();
		} catch (error) {
			return res.status(400).json({ message: "Invalid token" });
		}
	},
};


server.js:
const express = require("express");
const userRouter = require("./routers/userRouter");
const roomRouter = require("./routers/roomRouter");
const meetingRouter = require("./routers/meetingRouter");
const authRouter = require("./routers/authRouter"); // Update to authRouter
const { connect } = require("./configs/dbConfig"); // Import the connect function
require("dotenv").config();

const app = express();
const port = process.env.PORT || 8080;

app.use(express.json());
app.use(express.static("public")); // Serve static files from the public directory

app.use("/user", userRouter);
app.use("/room", roomRouter);
app.use("/meeting", meetingRouter);
app.use("/auth", authRouter); // Update to use authRouter

// Connect to the database when the server starts
connect()
	.then(() => {
		// Start the server after establishing the database connection
		app.listen(port, () => {
			console.log(`Server is running on port ${port}`);
		});
	})
	.catch((error) => {
		console.error("Error connecting to the database:", error);
		process.exit(1); // Exit with error
	});
