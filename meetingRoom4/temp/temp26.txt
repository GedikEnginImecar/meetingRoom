this is the error i got when trying to login:
Connection has been established successfully.
Executing (default): SELECT "userID", "permission", "username", "password", "department", "createdAt", "updatedAt" FROM "users" AS "user" WHERE "user"."username" = 'aaaa' LIMIT 1;
Error logging in user: Error: secretOrPrivateKey must have a value
    at module.exports [as sign] (C:\Users\Administrator\Documents\dev\Imecar\meetingRoom4\node_modules\jsonwebtoken\sign.js:111:20)
    at Object.generateRefreshToken (C:\Users\Administrator\Documents\dev\Imecar\meetingRoom4\middlewares\auth\auth.js:31:14)
    at login (C:\Users\Administrator\Documents\dev\Imecar\meetingRoom4\controllers\userController.js:65:38)


modified userController.js:
// userController.js

const { User, connect } = require("../configs/dbConfig"); // importing relevant model (with sequelize) from dbconfig
const { auth, tokens, cookies } = require("../middlewares/auth/auth"); // Import the auth object from auth.js

exports.userController = {
	// Controller function to register a new user
	async register(req, res) {
		await connect();
		try {
			const { username, password, permission, department } = req.body;

			// Check if a user with the same username already exists
			const existingUser = await User.findOne({
				where: { username },
			});
			if (existingUser) {
				return res.status(400).json({ message: "Username is already taken" });
			}

			// Hash the password
			const hashedPassword = await auth.hashPassword(password);

			// Create a new user in the database
			const newUser = await User.create({
				username,
				password: hashedPassword,
				permission,
				department,
			});

			res.status(201).json(newUser);
		} catch (error) {
			console.error("Error registering user:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	async login(req, res) {
		await connect();
		try {
			const { username, password } = req.body;

			// Find the user in the database
			const user = await User.findOne({
				where: { username },
			});

			if (!user) {
				return res
					.status(401)
					.json({ message: "Invalid username or password" });
			}

			// Check password
			const passwordMatch = await auth.checkPassword(password, user.password);
			if (!passwordMatch) {
				return res
					.status(401)
					.json({ message: "Invalid username or password" });
			}

			// Generate JWT tokens
			const accessToken = await tokens.generateAccessToken(user.userID);
			const refreshToken = await tokens.generateRefreshToken(user.userID);

			// Set access token as a cookie
			res.cookie("accessToken", accessToken, {
				httpOnly: false, // Access token should be accessible by JavaScript
			});

			// Set refresh token as an HTTP-only cookie
			res.cookie("refreshToken", refreshToken, {
				httpOnly: true, // Refresh token should not be accessible by JavaScript
			});

			res.json({ message: "Login successful" });
		} catch (error) {
			console.error("Error logging in user:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	// Function to get all users
	async getAllUsers(req, res) {
		await connect();
		try {
			// Retrieve all rooms from the database
			const users = await User.findAll();
			res.json(users);
		} catch (error) {
			console.error("Error retrieving users:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	// Controller function to get a room by ID
	async getUserByID(req, res) {
		await connect();
		try {
			const { userID } = req.params;
			const user = await User.findByPk(userID);
			if (!user) {
				return res.status(404).json({ message: "User not found" });
			}
			res.json(user);
		} catch (error) {
			console.error("Error retrieving user:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	// Controller function to get a user by name
	async getUserByName(req, res) {
		await connect();
		try {
			const { username } = req.params;
			const user = await User.findOne({ where: { username } });
			if (!user) {
				return res.status(404).json({ message: "User not found" });
			}
			res.json(user);
		} catch (error) {
			console.error("Error retrieving user:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	// Controller function to delete a user by ID
	async deleteUserByID(req, res) {
		await connect();
		try {
			const { userID } = req.params;

			// Find the user by ID
			const user = await User.findByPk(userID);
			if (!user) {
				return res.status(404).json({ message: "User not found" });
			}

			// Delete the user
			await user.destroy();

			res.json({ message: "User deleted successfully" });
		} catch (error) {
			console.error("Error deleting user:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	// Controller function to delete a user by username
	async deleteUserByName(req, res) {
		await connect();
		try {
			const { username } = req.params;

			// Find the user by username
			const user = await User.findOne({ where: { username } });
			if (!user) {
				return res.status(404).json({ message: "User not found" });
			}

			// Delete the user
			await user.destroy();

			res.json({ message: "User deleted successfully" });
		} catch (error) {
			console.error("Error deleting user:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},
};


modified login.js:
document.addEventListener("DOMContentLoaded", function () {
	const loginForm = document.getElementById("loginForm");
	const message = document.getElementById("message");

	loginForm.addEventListener("submit", async function (event) {
		event.preventDefault();
		const formData = new FormData(loginForm);
		const username = formData.get("username");
		const password = formData.get("password");

		try {
			const response = await fetch("/user/login", {
				method: "POST",
				headers: {
					"Content-Type": "application/json",
				},
				body: JSON.stringify({ username, password }),
			});

			if (response.ok) {
				const data = await response.json();
				// Redirect to dashboard on successful login
				window.location.href = "../html/dashboard.html";
			} else {
				const data = await response.json();
				message.textContent = data.message;
			}
		} catch (error) {
			console.error("Error:", error);
			message.textContent = "An error occurred while logging in";
		}
	});
});

userRouter.js:
const express = require("express");
const router = express.Router();
const { userController } = require("../controllers/userController");

const { auth, tokens, cookies } = require("../middlewares/auth/auth"); // Import auth

const {
	registerValidator,
	loginValidator,
} = require("../validators/userValidator");

// Route for user registration
router.post("/register", registerValidator, userController.register);

// Route for user login
router.post("/login", loginValidator, userController.login);

// Route to get all users
router.get("/users", userController.getAllUsers);

// Route to get a user by ID
router.get("/search/userID/:userID", userController.getUserByID);

// Route to get a user by name
router.get("/search/userName/:username", userController.getUserByName);

// Route to delete a user by ID (requires authentication)
router.delete(
	"/delete/userID/:userID",
	cookies.verifyAndAttachUser,
	userController.deleteUserByID
);

// Route to delete a user by username (requires authentication)
router.delete(
	"/delete/userName/:username",
	cookies.verifyAndAttachUser,
	userController.deleteUserByName
);

module.exports = router;



userValidator.js:
const { body, validationResult } = require("express-validator");

// Register Validator
exports.registerValidator = [
	body("username").notEmpty().isString(),
	body("password").notEmpty().isString(),
	body("permission").notEmpty().isIn([0, 1, 2, 3]).toInt(),
	body("department")
		.notEmpty()
		.isIn(["software", "engineering", "design", "owner"]),
	(req, res, next) => {
		const errors = validationResult(req);

		if (!errors.isEmpty()) {
			return res.status(400).json({ errors: errors.array() });
		}
		next();
	},
];

// Login Validator
exports.loginValidator = [
	body("username").notEmpty().isString(),
	body("password").notEmpty().isString(),
	(req, res, next) => {
		const errors = validationResult(req);

		if (!errors.isEmpty()) {
			return res.status(400).json({ errors: errors.array() });
		}
		next();
	},
];



auth.js:
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const { serialize, parse } = require("cookie");
require("dotenv").config();

// Load environment variables
const JWT_SECRET = process.env.JWT_SECRET;
const REFRESH_TOKEN_SECRET = process.env.REFRESH_TOKEN_SECRET;

// Number of salt rounds for password hashing
const saltRounds = 10;

exports.auth = {
	// Functions related to authentication (password hashing and verification)
	async hashPassword(password) {
		return await bcrypt.hash(password, saltRounds);
	},

	async checkPassword(password, hashedPassword) {
		return await bcrypt.compare(password, hashedPassword);
	},
};

exports.tokens = {
	// Functions related to tokens
	async generateAccessToken(userID) {
		return jwt.sign({ userID }, JWT_SECRET, { expiresIn: "15m" });
	},

	async generateRefreshToken(userID) {
		return jwt.sign({ userID }, REFRESH_TOKEN_SECRET, { expiresIn: "1.5h" });
	},
};

exports.cookies = {
	// Functions related to cookies
	async parseCookies(cookieHeader) {
		return parse(cookieHeader);
	},

	async verifyAndAttachUser(req, res, next) {
		const cookieHeader = req.headers.cookie;
		if (!cookieHeader) {
			return res.status(401).json({ message: "No cookies sent" });
		}

		const cookies = parse(cookieHeader);
		const token = cookies.token;

		if (!token) {
			return res.status(401).json({ message: "Token not found in cookies" });
		}

		try {
			const decoded = jwt.verify(token, JWT_SECRET);
			req.user = decoded; // Attach the decoded token to the request object
			next();
		} catch (error) {
			return res.status(400).json({ message: "Invalid token" });
		}
	},
};
