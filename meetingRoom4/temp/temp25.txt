authRouter.js:
const express = require("express");
const jwt = require("jsonwebtoken");
const cookieParser = require("cookie-parser"); // Import cookie-parser
const { cookies } = require("../middlewares/auth/auth");
const router = express.Router();

// Middleware to parse cookies
router.use(cookieParser());

// Route to decode the token cookie
router.get("/decodeToken", cookies.verifyAndAttachUser, (req, res) => {
	const decoded = req.user;
	res.json({ decoded });
});

module.exports = router;


auth.js:
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const { serialize, parse } = require("cookie");
require("dotenv").config();

// Load environment variables
const JWT_SECRET = process.env.JWT_SECRET;
const REFRESH_TOKEN_SECRET = process.env.REFRESH_TOKEN_SECRET;

// Number of salt rounds for password hashing
const saltRounds = 10;

exports.auth = {
	// Functions related to authentication (password hashing and verification)
	async hashPassword(password) {
		return await bcrypt.hash(password, saltRounds);
	},

	async checkPassword(password, hashedPassword) {
		return await bcrypt.compare(password, hashedPassword);
	},
};

exports.tokens = {
	// Functions related to tokens
	async generateAccessToken(userID) {
		return jwt.sign({ userID }, JWT_SECRET, { expiresIn: "15m" });
	},

	async generateRefreshToken(userID) {
		return jwt.sign({ userID }, REFRESH_TOKEN_SECRET, { expiresIn: "1.5h" });
	},
};

exports.cookies = {
	// Functions related to cookies
	async parseCookies(cookieHeader) {
		return parse(cookieHeader);
	},

	async verifyAndAttachUser(req, res, next) {
		const cookieHeader = req.headers.cookie;
		if (!cookieHeader) {
			return res.status(401).json({ message: "No cookies sent" });
		}

		const cookies = parse(cookieHeader);
		const token = cookies.token;

		if (!token) {
			return res.status(401).json({ message: "Token not found in cookies" });
		}

		try {
			const decoded = jwt.verify(token, JWT_SECRET);
			req.user = decoded; // Attach the decoded token to the request object
			next();
		} catch (error) {
			return res.status(400).json({ message: "Invalid token" });
		}
	},
};


server.js:
const express = require("express");
const cookieParser = require("cookie-parser"); // Import cookie-parser
const userRouter = require("./routers/userRouter");
const roomRouter = require("./routers/roomRouter");
const meetingRouter = require("./routers/meetingRouter");
const authRouter = require("./routers/authRouter"); // Update to authRouter
const { connect } = require("./configs/dbConfig"); // Import the connect function
require("dotenv").config();

const app = express();
const port = process.env.PORT || 8080;

app.use(express.json());
app.use(cookieParser()); // Use cookie-parser middleware
app.use(express.static("public")); // Serve static files from the public directory

app.use("/user", userRouter);
app.use("/room", roomRouter);
app.use("/meeting", meetingRouter);
app.use("/auth", authRouter); // Updated to use authRouter

// Connect to the database when the server starts
connect()
	.then(() => {
		// Start the server after establishing the database connection
		app.listen(port, () => {
			console.log(`Server is running on port ${port}`);
		});
	})
	.catch((error) => {
		console.error("Error connecting to the database:", error);
		process.exit(1); // Exit with error
	});


userController.js:
// userController.js

const { User, connect } = require("../configs/dbConfig"); // importing relevant model (with sequelize) from dbconfig
const { auth, tokens, cookies } = require("../middlewares/auth/auth"); // Import the auth object from auth.js

exports.userController = {
	// Controller function to register a new user
	async register(req, res) {
		await connect();
		try {
			const { username, password, permission, department } = req.body;

			// Check if a user with the same username already exists
			const existingUser = await User.findOne({
				where: { username },
			});
			if (existingUser) {
				return res.status(400).json({ message: "Username is already taken" });
			}

			// Hash the password
			const hashedPassword = await auth.hashPassword(password);

			// Create a new user in the database
			const newUser = await User.create({
				username,
				password: hashedPassword,
				permission,
				department,
			});

			res.status(201).json(newUser);
		} catch (error) {
			console.error("Error registering user:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	async login(req, res) {
		await connect();
		try {
			const { username, password } = req.body;

			// Find the user in the database
			const user = await User.findOne({
				where: { username },
			});

			if (!user) {
				return res
					.status(401)
					.json({ message: "Invalid username or password" });
			}

			// Check password
			const passwordMatch = await auth.checkPassword(password, user.password);
			if (!passwordMatch) {
				return res
					.status(401)
					.json({ message: "Invalid username or password" });
			}

			// Generate JWT token
			const token = tokens.generateAccessToken(user, res);
			res.json({ token });
		} catch (error) {
			console.error("Error logging in user:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	// Function to get all users
	async getAllUsers(req, res) {
		await connect();
		try {
			// Retrieve all rooms from the database
			const users = await User.findAll();
			res.json(users);
		} catch (error) {
			console.error("Error retrieving users:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	// Controller function to get a room by ID
	async getUserByID(req, res) {
		await connect();
		try {
			const { userID } = req.params;
			const user = await User.findByPk(userID);
			if (!user) {
				return res.status(404).json({ message: "User not found" });
			}
			res.json(user);
		} catch (error) {
			console.error("Error retrieving user:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	// Controller function to get a user by name
	async getUserByName(req, res) {
		await connect();
		try {
			const { username } = req.params;
			const user = await User.findOne({ where: { username } });
			if (!user) {
				return res.status(404).json({ message: "User not found" });
			}
			res.json(user);
		} catch (error) {
			console.error("Error retrieving user:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	// Controller function to delete a user by ID
	async deleteUserByID(req, res) {
		await connect();
		try {
			const { userID } = req.params;

			// Find the user by ID
			const user = await User.findByPk(userID);
			if (!user) {
				return res.status(404).json({ message: "User not found" });
			}

			// Delete the user
			await user.destroy();

			res.json({ message: "User deleted successfully" });
		} catch (error) {
			console.error("Error deleting user:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},

	// Controller function to delete a user by username
	async deleteUserByName(req, res) {
		await connect();
		try {
			const { username } = req.params;

			// Find the user by username
			const user = await User.findOne({ where: { username } });
			if (!user) {
				return res.status(404).json({ message: "User not found" });
			}

			// Delete the user
			await user.destroy();

			res.json({ message: "User deleted successfully" });
		} catch (error) {
			console.error("Error deleting user:", error);
			res.status(500).json({ message: "Internal server error" });
		}
	},
};


userRouter.js:
const express = require("express");
const router = express.Router();
const { userController } = require("../controllers/userController");

const { auth, tokens, cookies } = require("../middlewares/auth/auth"); // Import auth

const {
	registerValidator,
	loginValidator,
} = require("../validators/userValidator");

// Route for user registration
router.post("/register", registerValidator, userController.register);

// Route for user login
router.post("/login", loginValidator, userController.login);

// Route to get all users
router.get("/users", userController.getAllUsers);

// Route to get a user by ID
router.get("/search/userID/:userID", userController.getUserByID);

// Route to get a user by name
router.get("/search/userName/:username", userController.getUserByName);

// Route to delete a user by ID (requires authentication)
router.delete(
	"/delete/userID/:userID",
	cookies.verifyAndAttachUser,
	userController.deleteUserByID
);

// Route to delete a user by username (requires authentication)
router.delete(
	"/delete/userName/:username",
	cookies.verifyAndAttachUser,
	userController.deleteUserByName
);

module.exports = router;


userValidator.js:
const { body, validationResult } = require("express-validator");

// Register Validator
exports.registerValidator = [
	body("username").notEmpty().isString(),
	body("password").notEmpty().isString(),
	body("permission").notEmpty().isIn([0, 1, 2, 3]).toInt(),
	body("department")
		.notEmpty()
		.isIn(["software", "engineering", "design", "owner"]),
	(req, res, next) => {
		const errors = validationResult(req);

		if (!errors.isEmpty()) {
			return res.status(400).json({ errors: errors.array() });
		}
		next();
	},
];

// Login Validator
exports.loginValidator = [
	body("username").notEmpty().isString(),
	body("password").notEmpty().isString(),
	(req, res, next) => {
		const errors = validationResult(req);

		if (!errors.isEmpty()) {
			return res.status(400).json({ errors: errors.array() });
		}
		next();
	},
];


meetings.js:
// Function to handle window onload event
window.onload = async function () {
	try {
		const decodedToken = await decodeToken();

		if (decodedToken) {
			// If token is decoded successfully, use the decoded information
			console.log("Decoded Token:", decodedToken);
			loadRooms();
		} else {
			// If token decoding fails or not found
			alert("Failed to decode token or token not found");
		}
	} catch (error) {
		console.error("Error:", error);
		alert("Error decoding token");
	}
};

// Function to decode token by making a request to the server
async function decodeToken() {
	const response = await fetch("/auth/decodeToken", {
		// Update the endpoint path
		credentials: "include", // Important for including cookies in the request
	});
	if (response.ok) {
		const data = await response.json();
		const decodedToken = data.decoded;
		if (decodedToken) {
			// Populate the userID field in the HTML
			document.getElementById("userID").value = decodedToken.userID;
		}
		return decodedToken;
	} else {
		console.error("Failed to decode token:", response.statusText);
		return null;
	}
}

async function loadRooms() {
	try {
		const response = await fetch("/room/rooms"); // Fetch all rooms
		if (!response.ok) {
			throw new Error("Failed to fetch rooms");
		}
		const rooms = await response.json();
		const roomSelect = document.getElementById("roomSelect");
		rooms.forEach((room) => {
			const option = document.createElement("option");
			option.value = room.roomID;
			option.textContent = `${room.roomName} - ${room.department}`;
			roomSelect.appendChild(option);
		});

		// Automatically select the nearest past Monday as the starting date
		const currentDate = new Date();
		const dayOfWeek = currentDate.getDay();
		const daysToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
		const startOfWeek = new Date(currentDate);
		startOfWeek.setDate(currentDate.getDate() - daysToMonday);
		document.getElementById("startDate").value = startOfWeek
			.toISOString()
			.split("T")[0];

		// Load the calendar
		await loadCalendar();
	} catch (error) {
		console.error("Error loading rooms:", error.message);
	}
}

async function loadCalendar(roomID, startDate) {
	try {
		if (!roomID) {
			roomID = document.getElementById("roomSelect").value;
		}
		if (!startDate) {
			startDate = document.getElementById("startDate").value;
		}

		const endDate = addDays(startDate, 6);
		const response = await fetch(
			`/meeting/search/between/${startDate}/${endDate}/${roomID}`
		);
		if (!response.ok) {
			throw new Error("Failed to fetch meetings");
		}
		const meetings = await response.json();
		renderCalendar(meetings, startDate);
	} catch (error) {
		console.error("Error loading calendar:", error.message);
	}
}

function renderCalendar(meetings, startDate) {
	const calendar = document.getElementById("calendar");
	calendar.innerHTML = ""; // Clear previous calendar

	const daysOfWeek = [
		"Monday",
		"Tuesday",
		"Wednesday",
		"Thursday",
		"Friday",
		"Saturday",
		"Sunday",
	];

	for (let i = 0; i < 7; i++) {
		const currentDate = new Date(startDate);
		currentDate.setDate(currentDate.getDate() + i);

		const dayDiv = document.createElement("div");
		dayDiv.classList.add("day");
		dayDiv.textContent = `${
			daysOfWeek[i]
		} (${currentDate.toLocaleDateString()})`;

		meetings.forEach((meeting) => {
			const meetingDate = new Date(meeting.meetingDate);
			if (meetingDate.toDateString() === currentDate.toDateString()) {
				const meetingDiv = document.createElement("div");
				meetingDiv.classList.add("meeting");
				meetingDiv.textContent = `${meeting.meetingStart} - ${meeting.meetingEnd}`;
				meetingDiv.setAttribute("data-meeting-id", meeting.meetingID); // Add meeting ID as data attribute
				meetingDiv.addEventListener("click", () => {
					handleMeetingSelection(meeting.meetingID); // Call handleMeetingSelection with meeting ID on click
				});

				dayDiv.appendChild(meetingDiv);
			}
		});

		calendar.appendChild(dayDiv);
	}

	// Display selected meetings in the "View/Delete Meetings" section
	displaySelectedMeetings(meetings);
}

function addDays(dateString, days) {
	const date = new Date(dateString);
	date.setDate(date.getDate() + days);
	return date.toISOString().split("T")[0];
}

function prevWeek() {
	const startDate = document.getElementById("startDate").value;
	const newStartDate = addDays(startDate, -7); // Subtract 7 days to go to previous week
	document.getElementById("startDate").value = newStartDate;
	loadCalendar();
}

function nextWeek() {
	const startDate = document.getElementById("startDate").value;
	const newStartDate = addDays(startDate, 7); // Add 7 days to go to next week
	document.getElementById("startDate").value = newStartDate;
	loadCalendar();
}

function validateDate() {
	const selectedDate = new Date(document.getElementById("startDate").value);
	const dayOfWeek = selectedDate.getDay();

	if (dayOfWeek !== 1) {
		alert("Please select a Monday.");
		const currentDate = new Date();
		const dayDiff = (currentDate.getDay() - 1 + 7) % 7;
		const lastMonday = new Date(currentDate);
		lastMonday.setDate(currentDate.getDate() - dayDiff);
		document.getElementById("startDate").value = lastMonday
			.toISOString()
			.split("T")[0];
	} else {
		loadCalendar(); // Load calendar when a Monday is selected
	}
}

// Function to handle meeting selection
function handleMeetingSelection(meetingID) {
	const selectedMeeting = document.querySelector(
		`[data-meeting-id="${meetingID}"]`
	);
	selectedMeeting.classList.toggle("selected");
	// Add your logic here to handle the selected meeting
}

// Function to display selected meetings in the "View/Delete Meetings" section
function displaySelectedMeetings(meetings) {
	const meetingsList = document.querySelector(".meetings-list");
	meetingsList.innerHTML = ""; // Clear previous meetings

	meetings.forEach((meeting) => {
		const meetingItem = document.createElement("div");
		meetingItem.textContent = `${meeting.meetingStart} - ${meeting.meetingEnd}`;
		meetingsList.appendChild(meetingItem);
	});
}

// Function to delete selected meetings
async function deleteSelectedMeetings() {
	const selectedMeetings = document.querySelectorAll(".selected");
	const meetingIDs = Array.from(selectedMeetings).map((meeting) =>
		meeting.getAttribute("data-meeting-id")
	);

	try {
		for (const meetingID of meetingIDs) {
			const response = await fetch(`/meeting/delete/meetingID/${meetingID}`, {
				method: "DELETE",
			});
			if (!response.ok) {
				throw new Error(`Failed to delete meeting with ID ${meetingID}`);
			}
		}
		// Reload the calendar after deleting meetings
		loadCalendar();
	} catch (error) {
		console.error("Error deleting meetings:", error.message);
	}
}

// Function to create a meeting
async function createMeeting() {
	try {
		const userID = document.getElementById("userID").value;
		const roomID = document.getElementById("roomSelect").value;
		const meetingDate = document.getElementById("meetingDate").value;
		const meetingStart = document.getElementById("meetingStart").value;
		const meetingEnd = document.getElementById("meetingEnd").value;

		const response = await fetch("/meeting/create", {
			method: "POST",
			headers: {
				"Content-Type": "application/json",
			},
			body: JSON.stringify({
				userID,
				roomID,
				meetingDate,
				meetingStart,
				meetingEnd,
			}),
		});

		const data = await response.json();

		if (!response.ok) {
			throw new Error(data.message || "Failed to create meeting");
		}

		// Reload the calendar after creating the meeting
		loadCalendar();
	} catch (error) {
		console.error("Error creating meeting:", error.message);
		alert("Failed to create meeting: " + error.message);
	}
}

document
	.getElementById("roomSelect")
	.addEventListener("change", async function () {
		await loadCalendar(); // Trigger loading meetings for the selected room and current date range
	});


login.js:
document.addEventListener("DOMContentLoaded", function () {
	const loginForm = document.getElementById("loginForm");
	const message = document.getElementById("message");

	loginForm.addEventListener("submit", async function (event) {
		event.preventDefault();
		const formData = new FormData(loginForm);
		const username = formData.get("username");
		const password = formData.get("password");

		try {
			const response = await fetch("/user/login", {
				// Updated URL
				method: "POST",
				headers: {
					"Content-Type": "application/json",
				},
				body: JSON.stringify({ username, password }),
			});

			if (response.ok) {
				window.location.href = "../html/dashboard.html"; // Redirect to dashboard on successful login
			} else {
				const data = await response.json();
				message.textContent = data.message;
			}
		} catch (error) {
			console.error("Error:", error);
			message.textContent = "An error occurred while logging in";
		}
	});
});


